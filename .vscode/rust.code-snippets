{
  // Place your leetcode-rust workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }

  "Union Find": {
    "scope": "rust",
    "prefix": "uf",
    "body": [
      "struct UnionFind {",
      "\tdata: Vec<usize>,",
      "\tsize: Vec<usize>,",
      "}",
      "",
      "impl UnionFind {",
      "\tfn new(n: usize) -> Self {",
      "\t\tSelf {",
      "\t\t\tdata: (0..n).collect(),",
      "\t\t\tsize: vec![1; n],",
      "\t\t}",
      "\t}",
      "",
      "\tfn find(&mut self, a: usize) -> usize {",
      "\t\tif a == self.data[a] {",
      "\t\t\treturn a;",
      "\t\t}",
      "",
      "\t\tself.data[a] = self.find(self.data[a]);",
      "",
      "\t\tself.data[a]",
      "\t}",
      "",
      "\tfn union(&mut self, a: usize, b: usize) {",
      "\t\tlet a = self.find(a);",
      "\t\tlet b = self.find(b);",
      "",
      "\t\tif a == b {",
      "\t\t\treturn;",
      "\t\t}",
      "",
      "\t\tlet (a, b) = match self.size[a] < self.size[b] {",
      "\t\t\ttrue => (b, a),",
      "\t\t\tfalse => (a, b),",
      "\t\t};",
      "",
      "\t\tself.size[b] += self.size[a];",
      "\t\tself.data[a] = b;",
      "\t}",
      "}"
    ],
    "description": "Basic Union Find"
  },

  "Modular Math": {
    "scope": "rust",
    "prefix": "mod",
    "body": [
      "const MOD: i64 = 1_000_000_007;",
      "",
      "fn powmod<T>(a: T, b: T) -> T",
      "where",
      "\tT: TryInto<i64> + TryFrom<i64>,",
      "\t<T as TryInto<i64>>::Error: std::fmt::Debug,",
      "\t<T as TryFrom<i64>>::Error: std::fmt::Debug,",
      "{",
      "\tlet (mut a, mut b) = (a.try_into().unwrap(), b.try_into().unwrap());",
      "",
      "\tlet mut result = 1i64;",
      "",
      "\twhile b > 0 {",
      "\t\tif b & 1 == 1 {",
      "\t\t\tresult = (result * a) % MOD;",
      "\t\t}",
      "",
      "\t\ta = (a * a) % MOD;",
      "\t\tb >>= 1;",
      "\t}",
      "",
      "\tresult.try_into().unwrap()",
      "}",
      "",
      "fn inv<T>(a: T) -> T",
      "where",
      "\tT: TryInto<i64> + TryFrom<i64>,",
      "\t<T as TryInto<i64>>::Error: std::fmt::Debug,",
      "\t<T as TryFrom<i64>>::Error: std::fmt::Debug,",
      "{",
      "\tpowmod(a, (MOD - 2).try_into().unwrap())",
      "}",
      "",
      "const N: i64 = 100_000;",
      "",
      "static FACT: std::sync::LazyLock<Vec<i64>> = std::sync::LazyLock::new(|| {",
      "\tlet mut res = vec![1, 1];",
      "",
      "\tfor x in 2..=N {",
      "\t\tres.push(res.last().unwrap() * x % MOD);",
      "\t}",
      "",
      "\tres",
      "});",
      "",
      "static INV_FACT: std::sync::LazyLock<Vec<i64>> = std::sync::LazyLock::new(|| {",
      "\tlet mut res = vec![1, 1];",
      "",
      "\tfor x in 2..=N {",
      "\t\tres.push(res.last().unwrap() * inv(x) % MOD);",
      "\t}",
      "",
      "\tres",
      "});",
      "",
      "fn fact<T>(a: T) -> T",
      "where",
      "\tT: TryInto<usize> + TryFrom<i64>,",
      "\t<T as TryInto<usize>>::Error: std::fmt::Debug,",
      "\t<T as TryFrom<i64>>::Error: std::fmt::Debug,",
      "{",
      "\tFACT[a.try_into().unwrap()].try_into().unwrap()",
      "}",
      "",
      "fn inv_fact<T>(a: T) -> T",
      "where",
      "\tT: TryInto<usize> + TryFrom<i64>,",
      "\t<T as TryInto<usize>>::Error: std::fmt::Debug,",
      "\t<T as TryFrom<i64>>::Error: std::fmt::Debug,",
      "{",
      "\tINV_FACT[a.try_into().unwrap()].try_into().unwrap()",
      "}",
      "",
      "fn comb<T>(a: T, b: T) -> T",
      "where",
      "\tT: TryInto<usize> + TryFrom<i64>,",
      "\t<T as TryInto<usize>>::Error: std::fmt::Debug,",
      "\t<T as TryFrom<i64>>::Error: std::fmt::Debug,",
      "{",
      "\tlet (a, b) = (a.try_into().unwrap(), b.try_into().unwrap());",
      "",
      "\t(FACT[a] * INV_FACT[b] % MOD * INV_FACT[a - b] % MOD)",
      "\t\t.try_into()",
      "\t\t.unwrap()",
      "}"
    ],
    "description": "Various modular math functions (powmod, inv, fact, ...)"
  }
}
